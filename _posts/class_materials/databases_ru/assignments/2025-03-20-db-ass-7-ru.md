---
layout: post
title: "Базы данных | Задания для практического занятия 7"
description: Объединение нескольких таблиц с помощью JOIN в PostgreSQL.
date: 2025-03-20 00:00:01 +0500
categories: [class_materials,databases_ru,assignment]
---

## Объединение нескольких таблиц с помощью JOIN в PostgreSQL.

---
<details markdown="1">
<summary><strong>Вариант 1: Товары и категории в электронной коммерции</strong></summary>

**Сценарий:** Упрощенная система электронной коммерции должна категоризировать товары.

**Схема базы данных:**

**Таблицы:** `products` (товары), `categories` (категории)

```sql
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    category_name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT
);

CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2),
    category_id INTEGER REFERENCES categories(category_id)
);
```

**Пример данных:**

```sql
INSERT INTO categories (category_name, description) VALUES
('Electronics', 'Electronic devices and gadgets'),  -- Электроника, Электронные устройства и гаджеты
('Books', 'Literary works and publications'), -- Книги, Литературные произведения и публикации
('Clothing', 'Apparel and fashion items'), -- Одежда, Предметы одежды и модные товары
('Home Goods', 'Items for household use'); -- Товары для дома, Предметы для домашнего использования

INSERT INTO products (product_name, price, category_id) VALUES
('Laptop', 1200.00, 1), -- Ноутбук
('Smartphone', 800.00, 1), -- Смартфон
('T-Shirt', 25.00, 3), -- Футболка
('Novel - Mystery', 15.00, 2), -- Роман - Детектив
('Cookbook', 20.00, 2), -- Кулинарная книга
('Jeans', 60.00, 3), -- Джинсы
('Coffee Maker', 45.00, NULL), -- Кофеварка
('Tablet', 300.00, 1), -- Планшет
('Pillow', 25.00, NULL); -- Подушка
```

**Задания:**

1.  Используя `INNER JOIN`, выведите названия товаров и соответствующие им названия категорий.
2.  Используя `LEFT JOIN`, покажите все категории и названия товаров в каждой категории. Если в категории нет товаров, название товара должно быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите все товары и названия их категорий.  Подумайте, есть ли здесь отличие от `INNER JOIN`, и объясните, почему да или почему нет.
4.  Используя `FULL OUTER JOIN`, объедините категории и товары. Проанализируйте результат и объясните, что этот тип соединения подчеркивает в данном контексте.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации категорий и товаров.  Объясните сценарий, в котором `CROSS JOIN` мог бы быть полезен здесь.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите названия и цены товаров в категории 'Electronics' (Электроника).
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите все категории и названия товаров, но только для товаров, цена которых превышает 50 долларов. Если в категории нет таких товаров, покажите `NULL`.
8.  Используя `INNER JOIN`, найдите названия товаров и названия категорий, упорядочив результат по цене товара в порядке убывания.
9.  Используя `LEFT JOIN`, подсчитайте количество товаров в каждой категории. Отобразите название категории и количество. (Подсказка: вам может потребоваться использовать агрегатные функции и `GROUP BY` после соединения).
10. Используя `RIGHT JOIN`, выведите список всех товаров и названий их категорий, включая товары, которые могут быть не назначены ни одной категории (предполагая, что вы добавите такие данные). Если у товара нет категории, укажите название категории как 'Uncategorized' (Некатегоризированный). (Для этой задачи вам может потребоваться немного изменить данные, чтобы включить товар без категории, чтобы `RIGHT JOIN` явно отличался от `INNER JOIN`).
</details>
---
<details markdown="1">
<summary><strong>Вариант 2: Читатели библиотеки и книги</strong></summary>

**Сценарий:** Библиотечная система отслеживает читателей и книги, которые им интересны (список желаний).

**Схема базы данных:**

**Таблицы:** `patrons` (читатели), `wishlist_books` (список желаемых книг)

```sql
CREATE TABLE patrons (
    patron_id SERIAL PRIMARY KEY,
    patron_name VARCHAR(100) NOT NULL,
    library_card_number VARCHAR(20) UNIQUE,
    city VARCHAR(50)
);

CREATE TABLE wishlist_books (
    wishlist_id SERIAL PRIMARY KEY,
    patron_id INTEGER REFERENCES patrons(patron_id),
    book_title VARCHAR(150) NOT NULL,
    author VARCHAR(100)
);
```

**Пример данных:**

```sql
INSERT INTO patrons (patron_name, library_card_number, city) VALUES
('Alice Reader', 'LC123', 'New York'), -- Алиса Ридер
('Bob PageTurner', 'LC456', 'Los Angeles'), -- Боб ПейджТёрнер
('Charlie Bookworm', 'LC789', 'Chicago'), -- Чарли Букворм
('Diana LibraryFan', 'LC101', 'Houston'), -- Диана ЛайбрариФан
('Eve Novelist', 'LC112', 'New York'), -- Ева Новелист
('Frank Fictional', 'LC131', 'Los Angeles'); -- Фрэнк Фикшнал

INSERT INTO wishlist_books (patron_id, book_title, author) VALUES
(1, 'The Secret Garden', 'Frances Hodgson Burnett'), -- Таинственный сад
(NULL, 'Pride and Prejudice', 'Jane Austen'), -- Гордость и предубеждение
(1, 'To Kill a Mockingbird', 'Harper Lee'), -- Убить пересмешника
(3, '1984', 'George Orwell'), -- 1984
(4, 'The Great Gatsby', 'F. Scott Fitzgerald'), -- Великий Гэтсби
(NULL, 'Jane Eyre', 'Charlotte Brontë'), -- Джейн Эйр
(5, 'Moby Dick', 'Herman Melville'), -- Моби Дик
(6, 'Little Women', 'Louisa May Alcott'); -- Маленькие женщины
```

**Задания:**

1.  Используя `INNER JOIN`, получите список имен читателей и названий книг в их списках желаний.
2.  Используя `LEFT JOIN`, покажите всех читателей и названия книг в их списках желаний. Если у читателя нет книг в списке желаний, название книги должно быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите все книги из списка желаний и имена читателей, которые их пожелали. Есть ли в этом случае практическая разница с `INNER JOIN`? Объясните.
4.  Используя `FULL OUTER JOIN`, объедините читателей и книги из списка желаний. Проанализируйте результат и то, что он представляет.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации читателей и книг из списка желаний.  Обсудите потенциальные варианты использования `CROSS JOIN` в контексте списка желаний библиотеки.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите имена читателей и названия книг для книг в списке желаний, автором которых является 'Jane Austen' (Джейн Остин).
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите всех читателей и названия книг, но только для книг, название которых начинается с 'The' (предлог "The"). Если у читателя нет таких книг, покажите `NULL`.
8.  Используя `INNER JOIN`, найдите имена читателей и названия книг в списке желаний, упорядочив результат по имени читателя в алфавитном порядке.
9.  Используя `LEFT JOIN`, подсчитайте, сколько книг находится в списке желаний каждого читателя. Отобразите имя читателя и количество.
10. Используя `RIGHT JOIN`, выведите список всех книг из списка желаний и имена читателей, включая записи списка желаний, которые могут не иметь соответствующего читателя (предполагая несогласованность данных). Если у книги в списке желаний нет читателя, укажите имя читателя как 'Unknown Patron' (Неизвестный читатель). (Для этой задачи вам может потребоваться немного изменить данные, чтобы включить книгу из списка желаний с несуществующим patron_id, чтобы `RIGHT JOIN` был явно другим).
</details>
---
<details markdown="1">
<summary><strong>Вариант 3: Пользователи социальных сетей и действия</strong></summary>

**Сценарий:** Упрощенная платформа социальных сетей отслеживает пользователей и их действия (лайки).

**Схема базы данных:**

**Таблицы:** `users` (пользователи), `activities` (действия)

```sql
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    city VARCHAR(50)
);

CREATE TABLE activities (
    activity_id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(user_id),
    activity_type VARCHAR(50) NOT NULL, -- например, 'post_like', 'comment', 'follow'
    activity_timestamp TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

**Пример данных:**

```sql
INSERT INTO users (username, city) VALUES
('NetizenNick', 'London'), -- НетизенНик
('SocialSam', 'Paris'), -- СошиалСэм
('OnlineOlivia', 'New York'), -- ОнлайнОливия
('DigitalDan', 'London'), -- ДиджиталДэн
('TechTina', 'San Francisco'), -- ТекТина
('GlobalGreg', 'Tokyo'); -- ГлобалГрег

INSERT INTO activities (user_id, activity_type) VALUES
(1, 'post_like'), -- лайк поста
(NULL, 'comment'), -- комментарий
(1, 'follow'), -- подписка
(3, 'post_like'), -- лайк поста
(4, 'post_like'), -- лайк поста
(NULL, 'follow'), -- подписка
(5, 'comment'), -- комментарий
(6, 'post_like'), -- лайк поста
(3, 'follow'); -- подписка
```

**Задания:**

1.  Используя `INNER JOIN`, получите имена пользователей и типы их действий.
2.  Используя `LEFT JOIN`, покажите всех пользователей и типы их действий. Если у пользователя нет действий, тип действия должен быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите все действия и имена пользователей, которые их совершили. Объясните, дает ли `RIGHT JOIN` здесь иную информацию, чем `INNER JOIN`.
4.  Используя `FULL OUTER JOIN`, объедините пользователей и действия. Проанализируйте результат и оцените его значимость для понимания вовлеченности пользователей.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации пользователей и действий. Обсудите потенциальный, пусть и маловероятный, вариант использования `CROSS JOIN` в анализе активности в социальных сетях.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите имена пользователей и типы действий для действий типа 'post_like' (лайк поста).
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите всех пользователей и типы действий, но только для действий, которые произошли за последние 24 часа (вам может потребоваться скорректировать пример данных или использовать функции даты). Если недавних действий нет, покажите `NULL`.
8.  Используя `INNER JOIN`, найдите имена пользователей и типы действий, упорядочив результат по имени пользователя в алфавитном порядке.
9.  Используя `LEFT JOIN`, подсчитайте количество действий для каждого пользователя. Отобразите имя пользователя и количество действий.
10. Используя `RIGHT JOIN`, выведите список всех действий и имен пользователей, включая действия, которые могут быть связаны с несуществующим пользователем (предполагая несогласованность данных). Если у действия нет пользователя, укажите имя пользователя как 'Unknown User' (Неизвестный пользователь). (Для этого вам потребуется вставить действие с несуществующим `user_id`, чтобы `RIGHT JOIN` показал отличный результат).
</details>
---
<details markdown="1">
<summary><strong>Вариант 4: Авторы и статьи блог-платформы</strong></summary>

**Сценарий:** Блог-платформе необходимо управлять авторами и их статьями.

**Схема базы данных:**

**Таблицы:** `authors` (авторы), `articles` (статьи)

```sql
CREATE TABLE authors (
    author_id SERIAL PRIMARY KEY,
    author_name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE
);

CREATE TABLE articles (
    article_id SERIAL PRIMARY KEY,
    author_id INTEGER REFERENCES authors(author_id),
    article_title VARCHAR(200) NOT NULL,
    publication_date DATE NOT NULL
);
```

**Пример данных:**

```sql
INSERT INTO authors (author_name, email) VALUES
('Jane Doe', 'jane.doe@example.com'), -- Джейн Доу
('John Smith', 'john.smith@example.com'), -- Джон Смит
('Emily White', 'emily.white@example.com'), -- Эмили Уайт
('David Green', 'david.green@example.com'), -- Дэвид Грин
('Sophia Black', 'sophia.black@example.com'), -- София Блэк
('Oliver Brown', 'oliver.brown@example.com'); -- Оливер Браун

INSERT INTO articles (author_id, article_title, publication_date) VALUES
(1, 'The Future of Technology', '2024-08-01'), -- Будущее технологий
(NULL, 'Cooking at Home', '2024-08-05'), -- Готовим дома
(1, 'Travel in Europe', '2024-08-10'), -- Путешествия по Европе
(3, 'Gardening Tips', '2024-08-15'), -- Советы по садоводству
(4, 'Financial Planning', '2024-08-20'), -- Финансовое планирование
(NULL, 'Baking Desserts', '2024-08-25'), -- Выпечка десертов
(5, 'Photography Basics', '2024-08-30'), -- Основы фотографии
(6, 'Writing a Novel', '2024-09-05'); -- Как написать роман
```

**Задания:**

1.  Используя `INNER JOIN`, получите список имен авторов и названий их статей.
2.  Используя `LEFT JOIN`, покажите всех авторов и названия их статей. Если у автора нет статей, название статьи должно быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите все статьи и имена их авторов. Объясните, предоставляет ли `RIGHT JOIN` другую информацию, чем `INNER JOIN`, в этом сценарии.
4.  Используя `FULL OUTER JOIN`, объедините авторов и статьи. Проанализируйте результат и подумайте, когда `FULL OUTER JOIN` может быть полезен при управлении блогом.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации авторов и статей. Обсудите потенциальный вариант использования `CROSS JOIN` в контексте блог-платформы.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите имена авторов и названия статей, опубликованных в августе 2024 года.
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите всех авторов и названия статей, но только для статей, содержащих слово 'Cooking' (готовка). Если у автора нет таких статей, покажите NULL.
8.  Используя `INNER JOIN`, найдите имена авторов и названия статей, упорядочив результат по дате публикации в порядке возрастания.
9.  Используя `LEFT JOIN`, подсчитайте количество статей, написанных каждым автором. Отобразите имя автора и количество статей.
10. Используя `RIGHT JOIN`, выведите список всех статей и имен авторов, включая статьи, которые могут быть связаны с несуществующим автором (предполагая повреждение данных). Если у статьи нет автора, укажите имя автора как 'Unknown Author' (Неизвестный автор). (Для этого вставьте статью с несуществующим `author_id`, чтобы `RIGHT JOIN` продемонстрировал свое уникальное поведение).
</details>
---
<details markdown="1">
<summary><strong>Вариант 5: Музыкальные исполнители и песни</strong></summary>

**Сценарий:** Сервису потоковой передачи музыки необходимо управлять исполнителями и их песнями.

**Схема базы данных:**

**Таблицы:** `artists` (исполнители), `songs` (песни)

```sql
CREATE TABLE artists (
    artist_id SERIAL PRIMARY KEY,
    artist_name VARCHAR(100) NOT NULL UNIQUE,
    genre VARCHAR(50)
);

CREATE TABLE songs (
    song_id SERIAL PRIMARY KEY,
    artist_id INTEGER REFERENCES artists(artist_id),
    song_title VARCHAR(150) NOT NULL,
    duration_seconds INTEGER
);
```

**Пример данных:**

```sql
INSERT INTO artists (artist_name, genre) VALUES
('Rock Legends', 'Rock'), -- Рок-легенды
('Pop Sensation', 'Pop'), -- Поп-сенсация
('Jazz Virtuosos', 'Jazz'), -- Джазовые виртуозы
('Blues Masters', 'Blues'), -- Блюз-мастера
('Classical Harmony', 'Classical'), -- Классическая гармония
('Indie Vibes', 'Indie'); -- Инди-настроение

INSERT INTO songs (artist_id, song_title, duration_seconds) VALUES
(1, 'Stairway to Heaven', 480), -- Лестница в небеса
(NULL, 'Happy Tune', 240), -- Веселая мелодия
(1, 'Rock Anthem', 300), -- Рок-гимн
(3, 'Smooth Jazz', 360), -- Смус-джаз
(NULL, 'Pop Ballad', 270), -- Поп-баллада
(4, 'Blues Solo', 390), -- Блюзовое соло
(5, 'Symphony No. 5', 600), -- Симфония №5
(6, 'Indie Track', 210); -- Инди-трек
```

**Задания:**

1.  Используя `INNER JOIN`, получите список имен исполнителей и названий их песен.
2.  Используя `LEFT JOIN`, покажите всех исполнителей и названия их песен. Если у исполнителя нет песен, название песни должно быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите все песни и имена исполнителей, которые их исполнили. Есть ли здесь практическая разница между `RIGHT JOIN` и `INNER JOIN`? Объясните.
4.  Используя `FULL OUTER JOIN`, объедините исполнителей и песни. Проанализируйте результат и подумайте, когда `FULL OUTER JOIN` может быть полезен при управлении музыкальной базой данных.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации исполнителей и песен. Обсудите потенциальный вариант использования `CROSS JOIN` в контексте сервиса потоковой передачи музыки.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите имена исполнителей и названия песен, продолжительность которых превышает 300 секунд.
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите всех исполнителей и названия песен, но только для песен в жанре 'Pop' (Вам нужно будет так же присоединить и жанр исполнителя, или же подправить схему данных). Для исполнителей без поп-песен покажите NULL.
8.  Используя `INNER JOIN`, найдите имена исполнителей и названия песен, упорядочив результат по продолжительности песни в порядке убывания.
9.  Используя `LEFT JOIN`, подсчитайте количество песен для каждого исполнителя. Отобразите имя исполнителя и количество песен.
10. Используя `RIGHT JOIN`, выведите список всех песен и имен исполнителей, включая песни, которые могут быть связаны с несуществующим исполнителем (из-за ошибки ввода данных). Если у песни нет исполнителя, укажите имя исполнителя как 'Unknown Artist' (Неизвестный исполнитель).  (Для этого вставьте песню с несуществующим `artist_id`, чтобы `RIGHT JOIN` выделил свое поведение).
</details>
---
<details markdown="1">
<summary><strong>Вариант 6: Университетские курсы и преподаватели</strong></summary>

**Сценарий:** Базе данных университета необходимо управлять курсами и преподавателями, которые их ведут.

**Схема базы данных:**

**Таблицы:** `instructors` (преподаватели), `courses` (курсы)

```sql
CREATE TABLE instructors (
    instructor_id SERIAL PRIMARY KEY,
    instructor_name VARCHAR(100) NOT NULL,
    department VARCHAR(100)
);

CREATE TABLE courses (
    course_id SERIAL PRIMARY KEY,
    course_name VARCHAR(150) NOT NULL,
    credits INTEGER,
    instructor_id INTEGER REFERENCES instructors(instructor_id)
);
```

**Пример данных:**

```sql
INSERT INTO instructors (instructor_name, department) VALUES
('Dr. Smith', 'Computer Science'), -- Др. Смит, Информатика
('Prof. Jones', 'Mathematics'), -- Проф. Джонс, Математика
('Dr. Williams', 'Physics'), -- Др. Уильямс, Физика
('Prof. Brown', 'History'), -- Проф. Браун, История
('Dr. Davis', 'English'), -- Др. Дэвис, Английский язык
('Prof. Miller', 'Biology'); -- Проф. Миллер, Биология

INSERT INTO courses (course_name, credits, instructor_id) VALUES
('Intro to CS', 3, 1), -- Введение в информатику
('Calculus II', 4, NULL), -- Математический анализ II
('Quantum Physics', 3, 3), -- Квантовая физика
('American History', 3, 4), -- История Америки
('Shakespearean Lit', 3, 5), -- Литература Шекспира
('Genetics 101', 4, 6), -- Генетика 101
('Data Structures', 4, 1), -- Структуры данных
('Linear Algebra', 3, NULL); -- Линейная алгебра
```

**Задания:**

1.  Используя `INNER JOIN`, получите список имен преподавателей и названия курсов, которые они ведут.
2.  Используя `LEFT JOIN`, покажите всех преподавателей и названия курсов, которые они ведут. Если преподаватель не ведет никаких курсов, название курса должно быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите все курсы и имена преподавателей, которые их ведут. Объясните, показывает ли `RIGHT JOIN` другую информацию, чем `INNER JOIN`, здесь.
4.  Используя `FULL OUTER JOIN`, объедините преподавателей и курсы. Проанализируйте результат и подумайте, когда `FULL OUTER JOIN` может быть полезен при управлении университетскими курсами.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации преподавателей и курсов. Обсудите потенциальный, пусть и нереалистичный, вариант использования `CROSS JOIN` в университетском контексте.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите имена преподавателей и названия курсов для курсов с 4 кредитами.
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите всех преподавателей и названия курсов, но только для курсов, предлагаемых на кафедре 'Mathematics' (Математика) (вам может потребоваться присоединить кафедру преподавателя или изменить схему).  Для преподавателей не с кафедры математики покажите NULL.
8.  Используя `INNER JOIN`, найдите имена преподавателей и названия курсов, упорядочив результат по количеству кредитов курса в порядке убывания.
9.  Используя `LEFT JOIN`, подсчитайте количество курсов, которые ведет каждый преподаватель. Отобразите имя преподавателя и количество курсов.
10. Используя `RIGHT JOIN`, выведите список всех курсов и имен преподавателей, включая курсы, которые могут быть связаны с несуществующим преподавателем (из-за ошибки в базе данных). Если у курса нет преподавателя, укажите имя преподавателя как 'Unassigned Instructor' (Неназначенный преподаватель). (Для этого вставьте курс с несуществующим `instructor_id`, чтобы `RIGHT JOIN` продемонстрировал свою функцию).
</details>
---
<details markdown="1">
<summary><strong>Вариант 7: Пациенты больницы и врачи</strong></summary>

**Сценарий:** База данных больницы отслеживает пациентов и назначенных им врачей.

**Схема базы данных:**

**Таблицы:** `doctors` (врачи), `patients` (пациенты)

```sql
CREATE TABLE doctors (
    doctor_id SERIAL PRIMARY KEY,
    doctor_name VARCHAR(100) NOT NULL,
    specialization VARCHAR(50)
);

CREATE TABLE patients (
    patient_id SERIAL PRIMARY KEY,
    patient_name VARCHAR(100) NOT NULL,
    diagnosis VARCHAR(100),
    doctor_id INTEGER REFERENCES doctors(doctor_id)
);
```

**Пример данных:**

```sql
INSERT INTO doctors (doctor_name, specialization) VALUES
('Dr. Aisha Khan', 'Cardiology'), -- Доктор Аиша Хан, Кардиология
('Dr. Ben Carter', 'Oncology'), -- Доктор Бен Картер, Онкология
('Dr. Chloe Davis', 'Pediatrics'), -- Доктор Хлоя Дэвис, Педиатрия
('Dr. David Lee', 'Neurology'), -- Доктор Дэвид Ли, Неврология
('Dr. Emily Foster', 'Dermatology'), -- Доктор Эмили Фостер, Дерматология
('Dr. Frank Green', 'Orthopedics'); -- Доктор Фрэнк Грин, Ортопедия

INSERT INTO patients (patient_name, diagnosis, doctor_id) VALUES
('Patient Alpha', 'Hypertension', 1), -- Пациент Альфа, Гипертония
('Patient Beta', 'Leukemia', NULL), -- Пациент Бета, Лейкемия
('Patient Gamma', 'Asthma', 3), -- Пациент Гамма, Астма
('Patient Delta', 'Migraine', 4), -- Пациент Дельта, Мигрень
('Patient Epsilon', 'Eczema', 5), -- Пациент Эпсилон, Экзема
('Patient Zeta', 'Fractured Femur', 6), -- Пациент Зета, Перелом бедренной кости
('Patient Eta', 'Arrhythmia', 1), -- Пациент Эта, Аритмия
('Patient Theta', 'Melanoma', NULL); -- Пациент Тета, Меланома
```

**Задания:**

1.  Используя `INNER JOIN`, выведите имена пациентов и имена назначенных им врачей.
2.  Используя `LEFT JOIN`, покажите всех врачей и пациентов, которым они назначены. Если у врача нет пациентов, имя пациента должно быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите всех пациентов и имена их врачей. Объясните, предлагает ли `RIGHT JOIN` иную информацию, чем `INNER JOIN`, в этом контексте.
4.  Используя `FULL OUTER JOIN`, объедините врачей и пациентов. Проанализируйте результат и подумайте, когда `FULL OUTER JOIN` актуален в управлении больницей.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации врачей и пациентов.  Обсудите сценарий, в котором `CROSS JOIN` мог бы быть гипотетически полезен в больничном контексте.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите имена пациентов и имена врачей для пациентов с диагнозом 'Cancer' (Рак) (скорректируйте названия диагнозов в соответствии с примерами данных, например, 'Leukemia', 'Melanoma').
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите всех врачей и имена пациентов, но только для пациентов с диагнозом 'Hypertension' (Гипертония). Если у врача нет таких пациентов, покажите `NULL`.
8.  Используя `INNER JOIN`, найдите имена пациентов и имена врачей, упорядочив результат по имени врача в алфавитном порядке.
9.  Используя `LEFT JOIN`, подсчитайте количество пациентов, назначенных каждому врачу. Отобразите имя врача и количество пациентов.
10. Используя `RIGHT JOIN`, выведите список всех пациентов и имен врачей, включая пациентов, которые могут быть связаны с несуществующим врачом (из-за ошибок ввода данных). Если у пациента нет врача, укажите имя врача как 'Unassigned Doctor' (Неназначенный врач). (Для этого вставьте пациента с несуществующим `doctor_id`, чтобы `RIGHT JOIN` продемонстрировал свой вариант использования).
</details>
---
<details markdown="1">
<summary><strong>Вариант 8: Сообщения и пользователи онлайн-форума</strong></summary>

**Сценарий:** База данных онлайн-форума отслеживает пользователей и созданные ими сообщения.

**Схема базы данных:**

**Таблицы:** `forum_users` (пользователи форума), `forum_posts` (сообщения форума)

```sql
CREATE TABLE forum_users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    join_date DATE
);

CREATE TABLE forum_posts (
    post_id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES forum_users(user_id),
    post_title VARCHAR(200) NOT NULL,
    post_date DATE
);
```

**Пример данных:**

```sql
INSERT INTO forum_users (username, join_date) VALUES
('CodeCrusader', '2024-01-15'), -- КодКрусейдер
('DataNinja', '2024-02-20'), -- ДатаНиндзя
('SQLSamurai', '2024-03-10'), -- SQLСамурай
('WebWizard', '2024-04-05'), -- ВебВизард
('CyberPunk', '2024-05-22'), -- КиберПанк
('DebugDude', '2024-06-30'); -- ДебагДюд

INSERT INTO forum_posts (user_id, post_title, post_date) VALUES
(1, 'Introduction to SQL JOINs', '2024-07-01'), -- Введение в SQL JOIN
(NULL, 'Database Normalization Guide', '2024-07-05'), -- Руководство по нормализации баз данных
(1, 'Advanced PostgreSQL Features', '2024-07-10'), -- Расширенные возможности PostgreSQL
(3, 'Query Optimization Techniques', '2024-07-15'), -- Методы оптимизации запросов
(4, 'Frontend vs Backend Databases', '2024-07-20'), -- Фронтенд и бэкенд базы данных
(NULL, 'NoSQL vs SQL Databases', '2024-07-25'), -- NoSQL против SQL баз данных
(5, 'Cybersecurity in Databases', '2024-07-30'), -- Кибербезопасность в базах данных
(6, 'Troubleshooting Common SQL Errors', '2024-08-05'); -- Устранение распространенных ошибок SQL
```

**Задания:**

1.  Используя `INNER JOIN`, получите имена пользователей и названия их сообщений на форуме.
2.  Используя `LEFT JOIN`, покажите всех пользователей форума и названия их сообщений. Если у пользователя нет сообщений, название сообщения должно быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите все сообщения форума и имена пользователей, которые их создали.  Объясните, функционально ли `RIGHT JOIN` отличается от `INNER JOIN` в этом сценарии.
4.  Используя `FULL OUTER JOIN`, объедините пользователей форума и сообщения форума. Проанализируйте результат и рассмотрите использование `FULL OUTER JOIN` в аналитике форума.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации пользователей форума и сообщений форума. Обсудите гипотетический сценарий, в котором `CROSS JOIN` можно было бы использовать для анализа форума.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите имена пользователей и названия сообщений для сообщений, созданных в июле 2024 года.
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите всех пользователей форума и названия сообщений, но только для сообщений, содержащих слово 'Database' (База данных). Если у пользователя нет таких сообщений, покажите `NULL`.
8.  Используя `INNER JOIN`, найдите имена пользователей и названия сообщений, упорядочив результат по дате сообщения в порядке возрастания.
9.  Используя `LEFT JOIN`, подсчитайте количество сообщений, созданных каждым пользователем форума. Отобразите имя пользователя и количество сообщений.
10. Используя `RIGHT JOIN`, выведите список всех сообщений форума и имен пользователей, включая сообщения, которые могут быть связаны с несуществующим пользователем (из-за проблем с миграцией данных). Если у сообщения нет пользователя, укажите имя пользователя как 'Unknown User' (Неизвестный пользователь). (Для этого вставьте сообщение с несуществующим `user_id`, чтобы `RIGHT JOIN` продемонстрировал свое поведение).
</details>
---
<details markdown="1">
<summary><strong>Вариант 9: Сеансы кинотеатра и фильмы</strong></summary>

**Сценарий:** База данных кинотеатра управляет фильмами и расписанием их сеансов.

**Схема базы данных:**

**Таблицы:** `movies` (фильмы), `screenings` (сеансы)

```sql
CREATE TABLE movies (
    movie_id SERIAL PRIMARY KEY,
    movie_title VARCHAR(100) NOT NULL,
    genre VARCHAR(50)
);

CREATE TABLE screenings (
    screening_id SERIAL PRIMARY KEY,
    movie_id INTEGER REFERENCES movies(movie_id),
    screening_time TIMESTAMP WITHOUT TIME ZONE,
    room_number INTEGER
);
```

**Пример данных:**

```sql
INSERT INTO movies (movie_title, genre) VALUES
('Action Hero', 'Action'), -- Герой боевиков, Боевик
('Comedy Club', 'Comedy'), -- Комедийный клуб, Комедия
('Drama Queen', 'Drama'), -- Королева драмы, Драма
('Sci-Fi Saga', 'Science Fiction'), -- Научно-фантастическая сага, Научная фантастика
('Thriller Night', 'Thriller'), -- Вечер триллеров, Триллер
('Animated Adventure', 'Animation'); -- Анимационное приключение, Анимация

INSERT INTO screenings (movie_id, screening_time, room_number) VALUES
(1, '2024-09-10 14:00:00', 1), --  14:00
(NULL, '2024-09-10 16:30:00', 2), --  16:30
(1, '2024-09-10 19:00:00', 1), --  19:00
(3, '2024-09-11 15:00:00', 3), --  15:00
(4, '2024-09-11 18:00:00', 4), --  18:00
(NULL, '2024-09-11 21:00:00', 2), --  21:00
(5, '2024-09-12 13:30:00', 5), --  13:30
(6, '2024-09-12 17:00:00', 6); --  17:00
```

**Задания:**

1.  Используя `INNER JOIN`, получите названия фильмов и время их сеансов.
2.  Используя `LEFT JOIN`, покажите все фильмы и время их сеансов. Если у фильма нет сеансов, время сеанса должно быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите все сеансы и названия фильмов, которые на них показываются. Объясните, предоставляет ли `RIGHT JOIN` уникальную информацию по сравнению с `INNER JOIN` в этом контексте.
4.  Используя `FULL OUTER JOIN`, объедините фильмы и сеансы. Проанализируйте результат и рассмотрите полезность `FULL OUTER JOIN` в управлении кинотеатром.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации фильмов и сеансов.  Обсудите гипотетическое использование `CROSS JOIN` в работе кинотеатра, даже если это непрактично.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите названия фильмов и время сеансов для сеансов в зале номер 1.
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите все фильмы и время сеансов, но только для сеансов '2024-09-10'. Если у фильма нет сеансов в этот день, покажите `NULL`.
8.  Используя `INNER JOIN`, найдите названия фильмов и время сеансов, упорядочив результат по времени сеанса в порядке возрастания.
9.  Используя `LEFT JOIN`, подсчитайте количество сеансов для каждого фильма. Отобразите название фильма и количество сеансов.
10. Используя `RIGHT JOIN`, выведите список всех сеансов и названий фильмов, включая сеансы, которые могут быть связаны с несуществующим фильмом (из-за ошибок в расписании). Если у сеанса нет фильма, укажите название фильма как 'Movie Not Found' (Фильм не найден). (Для этого вставьте сеанс с несуществующим `movie_id`, чтобы `RIGHT JOIN` продемонстрировал свою функцию).
</details>
---
<details markdown="1">
<summary><strong>Вариант 10: Автосалон: Автомобили и Модели</strong></summary>

**Сценарий:** База данных автосалона отслеживает автомобили в наличии и информацию об их моделях.

**Схема базы данных:**

**Таблицы:** `car_models` (модели автомобилей), `cars` (автомобили)

```sql
CREATE TABLE car_models (
    model_id SERIAL PRIMARY KEY,
    model_name VARCHAR(50) NOT NULL UNIQUE,
    manufacturer VARCHAR(50)
);

CREATE TABLE cars (
    car_id SERIAL PRIMARY KEY,
    model_id INTEGER REFERENCES car_models(model_id),
    vin_number VARCHAR(50) UNIQUE,
    color VARCHAR(20)
);
```

**Пример данных:**

```sql
INSERT INTO car_models (model_name, manufacturer) VALUES
('Sedan X', 'AutoCorp'), -- Седан X
('SUV Max', 'Family Motors'), -- Внедорожник Max
('Sporty Z', 'Speedy Cars'), -- Спортивный Z
('Truck XL', 'Haul Trucks'), -- Грузовик XL
('Mini M', 'City Auto'), -- Мини M
('Convertible C', 'Open Road'); -- Кабриолет C

INSERT INTO cars (model_id, vin_number, color) VALUES
(1, 'VIN001', 'Red'), -- Красный
(NULL, 'VIN002', 'Blue'), -- Синий
(1, 'VIN003', 'Silver'), -- Серебристый
(3, 'VIN004', 'Black'), -- Черный
(4, 'VIN005', 'White'), -- Белый
(NULL, 'VIN006', 'Green'), -- Зеленый
(5, 'VIN007', 'Yellow'), -- Желтый
(6, 'VIN008', 'Orange'); -- Оранжевый
```

**Задания:**

1.  Используя `INNER JOIN`, получите VIN-номера автомобилей и названия их моделей.
2.  Используя `LEFT JOIN`, покажите все модели автомобилей и VIN-номера автомобилей каждой модели, имеющихся в наличии. Если у модели нет автомобилей в наличии, VIN-номер должен быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите все автомобили и названия их моделей. Есть ли практическая разница между `RIGHT JOIN` и `INNER JOIN` в этом случае? Объясните.
4.  Используя `FULL OUTER JOIN`, объедините модели автомобилей и автомобили. Проанализируйте результат и подумайте, когда `FULL OUTER JOIN` может быть полезен в управлении запасами автосалона.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации моделей автомобилей и автомобилей. Обсудите сценарий, в котором `CROSS JOIN` может быть использован в анализе автосалона, даже если это нетрадиционно.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите VIN-номера и названия моделей автомобилей, которые имеют цвет 'Red' (Красный).
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите все модели автомобилей и VIN-номера автомобилей, но только для автомобилей, произведенных компанией 'AutoCorp'. Если модель не произведена AutoCorp, покажите `NULL`.
8.  Используя `INNER JOIN`, найдите VIN-номера автомобилей и названия моделей, упорядочив результат по названию модели в алфавитном порядке.
9.  Используя `LEFT JOIN`, подсчитайте количество автомобилей в наличии для каждой модели. Отобразите название модели и количество автомобилей.
10. Используя `RIGHT JOIN`, выведите список всех автомобилей и названий моделей, включая автомобили, которые могут быть связаны с несуществующей моделью автомобиля (из-за ошибки ввода данных). Если у автомобиля нет модели, укажите название модели как 'Unknown Model' (Неизвестная модель). (Для этого вставьте автомобиль с несуществующим `model_id`, чтобы `RIGHT JOIN` продемонстрировал свою функцию).
</details>
---
<details markdown="1">
<summary><strong>Вариант 11: Туристическое агентство: Бронирования и Клиенты</strong></summary>

**Сценарий:** База данных туристического агентства отслеживает бронирования клиентов для различных поездок.

**Схема базы данных:**

**Таблицы:** `customers` (клиенты), `bookings` (бронирования)

```sql
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    customer_name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE,
    phone_number VARCHAR(20)
);

CREATE TABLE bookings (
    booking_id SERIAL PRIMARY KEY,
    customer_id INTEGER REFERENCES customers(customer_id),
    trip_destination VARCHAR(100) NOT NULL,
    booking_date DATE
);
```

**Пример данных:**

```sql
INSERT INTO customers (customer_name, email, phone_number) VALUES
('Alice Wonderland', 'alice@example.com', '123-456-7890'), -- Алиса Уандерленд
('Bob The Builder', 'bob@example.com', '987-654-3210'), -- Боб Строитель
('Charlie Chaplin', 'charlie@example.com', '111-222-3333'), -- Чарли Чаплин
('Diana Prince', 'diana@example.com', '444-555-6666'), -- Диана Принс
('Eve Harrington', 'eve@example.com', '777-888-9999'), -- Ева Харрингтон
('Frank Sinatra', 'frank@example.com', '101-202-3030'); -- Фрэнк Синатра

INSERT INTO bookings (customer_id, trip_destination, booking_date) VALUES
(1, 'Paris', '2024-09-01'), -- Париж
(NULL, 'Rome', '2024-09-05'), -- Рим
(1, 'Tokyo', '2024-09-10'), -- Токио
(3, 'London', '2024-09-15'), -- Лондон
(4, 'New York', '2024-09-20'), -- Нью-Йорк
(NULL, 'Barcelona', '2024-09-25'), -- Барселона
(5, 'Sydney', '2024-09-30'), -- Сидней
(6, 'Cairo', '2024-10-05'); -- Каир
```

**Задания:**

1.  Используя `INNER JOIN`, получите имена клиентов и пункты назначения их поездок.
2.  Используя `LEFT JOIN`, покажите всех клиентов и забронированные ими пункты назначения поездок. Если у клиента нет бронирований, пункт назначения поездки должен быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите все бронирования и имена клиентов, которые их сделали. Есть ли здесь практическая разница между `RIGHT JOIN` и `INNER JOIN`? Объясните.
4.  Используя `FULL OUTER JOIN`, объедините клиентов и бронирования. Проанализируйте результат и подумайте, когда `FULL OUTER JOIN` может быть полезен в работе туристического агентства.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации клиентов и бронирований. Обсудите гипотетическое использование `CROSS JOIN` в анализе туристического агентства.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите имена клиентов и пункты назначения для поездок в 'Paris' (Париж).
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите всех клиентов и пункты назначения поездок, но только для бронирований, сделанных в сентябре 2024 года. Если у клиента нет таких бронирований, покажите `NULL`.
8.  Используя `INNER JOIN`, найдите имена клиентов и пункты назначения поездок, упорядочив результат по дате бронирования в порядке возрастания.
9.  Используя `LEFT JOIN`, подсчитайте количество бронирований, сделанных каждым клиентом. Отобразите имя клиента и количество бронирований.
10. Используя `RIGHT JOIN`, выведите список всех бронирований и имен клиентов, включая бронирования, которые могут быть связаны с несуществующим клиентом (из-за ошибки ввода данных). Если у бронирования нет клиента, укажите имя клиента как 'Unknown Customer' (Неизвестный клиент). (Для этого вставьте бронирование с несуществующим `customer_id`, чтобы продемонстрировать поведение `RIGHT JOIN`).
</details>
---
<details markdown="1">
<summary><strong>Вариант 12: Запись на онлайн-курсы и Студенты</strong></summary>

**Сценарий:** База данных платформы онлайн-обучения отслеживает записи студентов на курсы.

**Схема базы данных:**

**Таблицы:** `online_students` (онлайн-студенты), `course_enrollments` (записи на курсы)

```sql
CREATE TABLE online_students (
    student_id SERIAL PRIMARY KEY,
    student_name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE
);

CREATE TABLE course_enrollments (
    enrollment_id SERIAL PRIMARY KEY,
    student_id INTEGER REFERENCES online_students(student_id),
    course_title VARCHAR(150) NOT NULL,
    enrollment_date DATE
);
```

**Пример данных:**

```sql
INSERT INTO online_students (student_name, email) VALUES
('Anna Learner', 'anna@learn.com'), -- Анна Лернер
('Ben Study', 'ben@study.edu'), -- Бен Стади
('Cathy Online', 'cathy@online.org'), -- Кэти Онлайн
('David Course', 'david@course.net'), -- Дэвид Курс
('Emily Class', 'emily@class.info'), -- Эмили Класс
('Frank Virtual', 'frank@virtual.com'); -- Фрэнк Виртуал

INSERT INTO course_enrollments (student_id, course_title, enrollment_date) VALUES
(1, 'Web Development Basics', '2024-08-15'), -- Основы веб-разработки
(NULL, 'Data Science Fundamentals', '2024-08-20'), -- Основы науки о данных
(1, 'Advanced JavaScript', '2024-08-25'), -- Продвинутый JavaScript
(3, 'Python for Beginners', '2024-08-30'), -- Python для начинающих
(4, 'Machine Learning Intro', '2024-09-01'), -- Введение в машинное обучение
(NULL, 'SQL for Data Analysis', '2024-09-05'), -- SQL для анализа данных
(5, 'Cloud Computing Essentials', '2024-09-10'), -- Основы облачных вычислений
(6, 'Cybersecurity Awareness', '2024-09-15'); -- Осведомленность о кибербезопасности
```

**Задания:**

1.  Используя `INNER JOIN`, получите имена студентов и названия курсов, на которые они записаны.
2.  Используя `LEFT JOIN`, покажите всех онлайн-студентов и курсы, на которые они записаны. Если студент не записан ни на один курс, название курса должно быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите все записи на курсы и имена зачисленных студентов. Объясните, предоставляет ли `RIGHT JOIN` здесь иную информацию, чем `INNER JOIN`.
4.  Используя `FULL OUTER JOIN`, объедините онлайн-студентов и записи на курсы. Проанализируйте результат и подумайте, когда `FULL OUTER JOIN` может быть полезен при управлении платформами онлайн-обучения.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации онлайн-студентов и записей на курсы. Обсудите гипотетический сценарий, в котором `CROSS JOIN` можно было бы использовать в анализе онлайн-образования.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите имена студентов и названия курсов для записей на курс 'Data Science Fundamentals' (Основы науки о данных).
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите всех онлайн-студентов и названия курсов, но только для курсов, на которые были записаны в августе 2024 года. Если у студента нет таких записей, покажите `NULL`.
8.  Используя `INNER JOIN`, найдите имена студентов и названия курсов, упорядочив результат по названию курса в алфавитном порядке.
9.  Используя `LEFT JOIN`, подсчитайте количество курсов, на которые записан каждый онлайн-студент. Отобразите имя студента и количество курсов.
10. Используя `RIGHT JOIN`, выведите список всех записей на курсы и имен студентов, включая записи, которые могут быть связаны с несуществующим студентом (из-за проблем с синхронизацией данных). Если у записи нет студента, укажите имя студента как 'Student Not Found' (Студент не найден). (Для этого вставьте запись на курс с несуществующим `student_id`, чтобы продемонстрировать функцию `RIGHT JOIN`).
</details>
---
<details markdown="1">
<summary><strong>Вариант 13: Заказы в ресторане и пункты меню</strong></summary>

**Сценарий:** База данных ресторана отслеживает заказы клиентов и пункты меню, включенные в каждый заказ.

**Схема базы данных:**

**Таблицы:** `menu_items` (пункты меню), `orders` (заказы)

```sql
CREATE TABLE menu_items (
    item_id SERIAL PRIMARY KEY,
    item_name VARCHAR(100) NOT NULL,
    category VARCHAR(50),
    price DECIMAL(5, 2)
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    item_id INTEGER REFERENCES menu_items(item_id),
    order_time TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    table_number INTEGER
);
```

**Пример данных:**

```sql
INSERT INTO menu_items (item_name, category, price) VALUES
('Margherita Pizza', 'Pizza', 12.99), -- Пицца Маргарита
('Chicken Caesar Salad', 'Salad', 9.50), -- Салат Цезарь с курицей
('Beef Burger', 'Burger', 11.75), -- Говяжий бургер
('Vegetarian Pasta', 'Pasta', 10.25), -- Вегетарианская паста
('Chocolate Cake', 'Dessert', 6.50), -- Шоколадный торт
('Iced Tea', 'Drinks', 2.99); -- Холодный чай

INSERT INTO orders (item_id, table_number) VALUES
(1, 101),
(2, 101),
(NULL, 102),
(1, 103),
(4, 102),
(5, 104),
(6, 103),
(NULL, 104);
```

**Задания:**

1.  Используя `INNER JOIN`, получите названия пунктов меню и идентификаторы заказов, частью которых они являются.
2.  Используя `LEFT JOIN`, покажите все пункты меню и идентификаторы заказов, в которые они были включены. Если пункт не был заказан, идентификатор заказа должен быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите все заказы и названия заказанных пунктов меню. Объясните, предлагает ли `RIGHT JOIN` другую точку зрения по сравнению с `INNER JOIN` в этом контексте.
4.  Используя `FULL OUTER JOIN`, объедините пункты меню и заказы. Проанализируйте результат и подумайте, когда `FULL OUTER JOIN` может быть полезен при анализе заказов в ресторане.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации пунктов меню и заказов. Обсудите гипотетический сценарий, в котором `CROSS JOIN` можно было бы использовать в управлении рестораном.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите названия пунктов меню и идентификаторы заказов для заказов за столиком номер 102.
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите все пункты меню и идентификаторы заказов, но только для пунктов из категории 'Pizza' (Пицца). Если пункт не относится к категории 'Pizza', покажите `NULL` (учитывая все перечисленные пункты меню).
8.  Используя `INNER JOIN`, найдите названия пунктов меню и идентификаторы заказов, упорядочив результат по цене пункта в порядке убывания.
9.  Используя `LEFT JOIN`, подсчитайте количество заказов для каждого пункта меню. Отобразите название пункта и количество заказов.
10. Используя `RIGHT JOIN`, выведите список всех заказов и названий пунктов меню, включая заказы, которые могут быть связаны с несуществующим пунктом меню (из-за ошибок ввода данных). Если у заказа нет пункта меню, укажите название пункта как 'Item Not Found' (Пункт не найден). (Для этого вставьте заказ с несуществующим `item_id`, чтобы `RIGHT JOIN` продемонстрировал свою функцию).
</details>
---
<details markdown="1">
<summary><strong>Вариант 14: Задачи по управлению проектами и сотрудники</strong></summary>

**Сценарий:** Система управления проектами отслеживает сотрудников и задачи, назначенные им.

**Схема базы данных:**

**Таблицы:** `employees` (сотрудники), `tasks` (задачи)

```sql
CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    employee_name VARCHAR(100) NOT NULL,
    department VARCHAR(50)
);

CREATE TABLE tasks (
    task_id SERIAL PRIMARY KEY,
    employee_id INTEGER REFERENCES employees(employee_id),
    task_description VARCHAR(200) NOT NULL,
    due_date DATE
);
```

**Пример данных:**

```sql
INSERT INTO employees (employee_name, department) VALUES
('Alice Manager', 'Management'), -- Алиса Менеджер
('Bob Developer', 'Development'), -- Боб Разработчик
('Charlie Designer', 'Design'), -- Чарли Дизайнер
('Diana Tester', 'Testing'), -- Диана Тестировщик
('Eve Analyst', 'Analysis'), -- Ева Аналитик
('Frank Support', 'Support'); -- Фрэнк Поддержка

INSERT INTO tasks (employee_id, task_description, due_date) VALUES
(1, 'Project Planning', '2024-10-20'), -- Планирование проекта
(NULL, 'Develop User Interface', '2024-10-25'), -- Разработка пользовательского интерфейса
(1, 'Team Coordination', '2024-10-30'), -- Координация команды
(3, 'Design Mockups', '2024-11-05'), -- Дизайн макетов
(4, 'Testing Phase 1', '2024-11-10'), -- Тестирование, фаза 1
(NULL, 'Implement Backend Logic', '2024-11-15'), -- Реализация серверной логики
(5, 'Data Analysis Report', '2024-11-20'), -- Отчет по анализу данных
(6, 'Customer Support Training', '2024-11-25'); -- Обучение службы поддержки клиентов
```

**Задания:**

1.  Используя `INNER JOIN`, получите имена сотрудников и описания задач, назначенных им.
2.  Используя `LEFT JOIN`, покажите всех сотрудников и описания назначенных им задач. Если сотруднику не назначены задачи, описание задачи должно быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите все задачи и имена сотрудников, назначенных им. Объясните, предоставляет ли `RIGHT JOIN` другую информацию по сравнению с `INNER JOIN` в этом контексте.
4.  Используя `FULL OUTER JOIN`, объедините сотрудников и задачи. Проанализируйте результат и подумайте, когда `FULL OUTER JOIN` может быть полезен в отчетности по управлению проектами.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации сотрудников и задач. Обсудите гипотетический сценарий, в котором `CROSS JOIN` можно было бы использовать в управлении проектами.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите имена сотрудников и описания задач для задач, срок выполнения которых наступает после '2024-11-01'.
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите всех сотрудников и описания задач, но только для задач, связанных с отделом 'Development' (Разработка) (вам может потребоваться объединить отдел сотрудника или изменить схему). Для сотрудников, не относящихся к отделу 'Development', покажите `NULL`.
8.  Используя `INNER JOIN`, найдите имена сотрудников и описания задач, упорядочив результат по дате выполнения в порядке возрастания.
9.  Используя `LEFT JOIN`, подсчитайте количество задач, назначенных каждому сотруднику. Отобразите имя сотрудника и количество задач.
10. Используя `RIGHT JOIN`, выведите список всех задач и имен сотрудников, включая задачи, которые могут быть связаны с несуществующим сотрудником (из-за ухода сотрудника). Если у задачи нет сотрудника, укажите имя сотрудника как 'Unassigned Employee' (Сотрудник не назначен). (Для этого вставьте задачу с несуществующим `employee_id`, чтобы `RIGHT JOIN` продемонстрировал свое использование).
</details>
---
<details markdown="1">
<summary><strong>Вариант 15: Билеты на мероприятия и посетители</strong></summary>

**Сценарий:** Система продажи билетов на мероприятия отслеживает посетителей и билеты, которые они приобрели на мероприятия.

**Схема базы данных:**

**Таблицы:** `events` (мероприятия), `attendees` (посетители)

```sql
CREATE TABLE events (
    event_id SERIAL PRIMARY KEY,
    event_name VARCHAR(100) NOT NULL,
    event_date DATE
);

CREATE TABLE attendees (
    attendee_id SERIAL PRIMARY KEY,
    event_id INTEGER REFERENCES events(event_id),
    attendee_name VARCHAR(100) NOT NULL,
    ticket_type VARCHAR(50)
);
```

**Пример данных:**

```sql
INSERT INTO events (event_name, event_date) VALUES
('Tech Conference 2024', '2024-12-05'), -- Техническая конференция 2024
('Music Festival Fall', '2024-12-10'), -- Музыкальный фестиваль Осень
('Art Exhibition Gala', '2024-12-15'), -- Гала-выставка искусств
('Food Fair Winter', '2024-12-20'), -- Зимняя ярмарка еды
('Science Symposium', '2024-12-25'), -- Научный симпозиум
('Literature Festival', '2024-12-30'); -- Литературный фестиваль

INSERT INTO attendees (event_id, attendee_name, ticket_type) VALUES
(1, 'Attendee One', 'Regular'), -- Посетитель Один, Обычный
(NULL, 'Attendee Two', 'VIP'), -- Посетитель Два, VIP
(1, 'Attendee Three', 'Regular'), -- Посетитель Три, Обычный
(3, 'Attendee Four', 'Regular'), -- Посетитель Четыре, Обычный
(4, 'Attendee Five', 'VIP'), -- Посетитель Пять, VIP
(NULL, 'Attendee Six', 'Regular'), -- Посетитель Шесть, Обычный
(5, 'Attendee Seven', 'Regular'), -- Посетитель Семь, Обычный
(6, 'Attendee Eight', 'VIP'); -- Посетитель Восемь, VIP
```

**Задания:**

1.  Используя `INNER JOIN`, получите названия мероприятий и имена посетителей, у которых есть на них билеты.
2.  Используя `LEFT JOIN`, покажите все мероприятия и имена посетителей для каждого мероприятия. Если на мероприятии еще нет посетителей, имя посетителя должно быть `NULL`.
3.  Используя `RIGHT JOIN`, выведите всех посетителей и названия мероприятий, которые они посещают. Объясните, предлагает ли `RIGHT JOIN` <span class="easter-egg" onclick="showEasterEgg()">здесь</span> иную информацию, чем `INNER JOIN`.
4.  Используя `FULL OUTER JOIN`, объедините мероприятия и посетителей. Проанализируйте результат и подумайте, когда `FULL OUTER JOIN` может быть полезен в управлении мероприятиями.
5.  Используя `CROSS JOIN`, сгенерируйте все комбинации мероприятий и посетителей. Обсудите гипотетический сценарий, в котором `CROSS JOIN` можно было бы использовать при планировании мероприятий.
6.  Используя `INNER JOIN` с предложением `WHERE`, найдите названия мероприятий и имена посетителей для посетителей с билетами типа 'VIP'.
7.  Используя `LEFT JOIN` и предложение `WHERE`, покажите все мероприятия и имена посетителей, но только для мероприятий, проходящих в декабре 2024 года. Если мероприятие не проводится в декабре, покажите `NULL` (учитывая все перечисленные мероприятия).
8.  Используя `INNER JOIN`, найдите названия мероприятий и имена посетителей, упорядочив результат по дате мероприятия в порядке возрастания.
9.  Используя `LEFT JOIN`, подсчитайте количество посетителей каждого мероприятия. Отобразите название мероприятия и количество посетителей.
10. Используя `RIGHT JOIN`, выведите список всех посетителей и названий мероприятий, включая посетителей, которые могут быть связаны с несуществующим мероприятием (из-за несоответствий данных). Если у посетителя нет мероприятия, укажите название мероприятия как 'Event Not Found' (Мероприятие не найдено). (Для этого вставьте посетителя с несуществующим `event_id`, чтобы `RIGHT JOIN` продемонстрировал свою функцию).
</details>
---

## Инструкции по сдаче

* Создайте новый Google Doc. [Пример](https://docs.google.com/document/d/12X5MHJDe4Ht_nU99dUX60FknnBwG1eKmCUtdqJ1fmIQ/edit?usp=sharing)
* Добавьте ссылку на ваш Google Doc здесь: [Google Таблица](https://docs.google.com/spreadsheets/d/1yN8duVr-vGAOTfUZ9YLGFwY2rbZ4Q4rQVrSmea9sESU/edit?usp=sharing)

<div id="easterEggGif">
    <img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExc3Y4NDl6Z2ZsdXdqZ3U2YzVrdnIwYmVrOTFzanIwcnhxMnNkbXFsbCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/Ju7l5y9osyymQ/giphy.gif" alt="Playful GIF">
</div>

{% include chat_component.html url="https://astounding-treacle-ae7505.netlify.app/.netlify/functions/lb_db_ai_tutor_ru" lang="RU"%}

<script>
    let isVisible = false;
    function showEasterEgg() {
        const eggDiv = document.getElementById('easterEggGif');
        if (!isVisible) {
            eggDiv.style.display = 'block';
            isVisible = true;
        }
    }
</script>